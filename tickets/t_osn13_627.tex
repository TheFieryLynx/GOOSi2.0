\nsection{OSN 13 Граф зависимостей программы: определение, построение, применение.}

Чтобы обнаружить все возможные при помощи добавления постоянного количества синхронизаций распараллеливания, можно применить <<жадное>> расщепление исходной программы. Разобьем циклы на максимально возможное количество отдельных циклов, а затем независимо распараллелим каждый из циклов.

Чтобы найти все возможные расщепления цикла, воспользуемся абстракцией \textbf{графа зависимостей программы} (program-dependence graph - PDG). Граф зависимостей программы представляет собой граф, узлами которого являются инструк-ции присваивания в программе, а ребра указывают зависимости данных между инструкциями и их направления. Ребро от инструкции $s_{1}$ к инструкции $s_{2}$ имеется в том случае, когда имеется зависимость данных между некоторым динамическим экземпляром $s_{1}$ и более \textit{поздним} динамическим экземпляром $s_{2}$.


Для построения PDG программы мы сначала находим все зависимости данных между каждой парой (не обязательно различных) статических обращений в каждой паре (не обязательно различных) инструкций. Предположим, мы определили, что существует зависимость между обращением $\mathcal{F}_{1}$ в инструкции $s_{1}$ и обращением $\mathcal{F}_{2}$ в инструкции $s_{2}$. Вспомним, что экземпляр инструкции определяется индексным вектором \textbf{і} = [$i_{1}$, $i_{2}$, ..., $i_{m}$], где $i_{k}$ индекс цикла \textit{k}-й вложенности, в котором находится рассматриваемая инструкция.
\begin{enumerate}
    \item Если существует зависимая пара экземпляров, $i_{1}$ инструкции $s_{1}$ и $i_{2}$ инструкции $s_{2}$, и $i_{i}$ в исходной программе выполняется до $i_{2}$, что записывается как $i_{1}\prec _{s_{1}s_{2}}i_{2}$, то в PDG имеется ребро от $s_{1}$ К $s_{2}$.
    
    \item Аналогично, если существует зависимая пара экземпляров, $i_{1}$ инструкции $s_{1}$ и $i_{2}$ инструкции $s_{2}$, и $i_{2}\prec _{s_{1}s_{2}}i_{1}$, то в PDG имеется ребро от $s_{2}$ К $s_{1}$.
\end{enumerate}
 
Заметим, что возможна ситуация, когда зависимости данных между инструкциями $s_{1}$ и $s_{2}$ генерируют как ребро от $s_{1}$ к $s_{2}$, так и ребро от $s_{2}$ к $s_{1}$.

В частном случае совпадения инструкций $s_{1}$ И $s_{2}$ $i_{1}\prec _{s_{1}s_{2}}i_{2}$ тогда и только тогда, когда $i_{1}\prec i_{2}$ ($i_{1}$ лексикографически меньше $i_{2}$). В общем случае $s_{1}$ и $s{2}$ могут быть различными инструкциями, возможно, принадлежащими разным вложенностям циклов.

Граф зависимостей программы облегчает определение того, можно ли разде- лить инструкции в цикле. Инструкции, соединенные в цикл в PDG, разделены быть не могут. Если $s_{1} \to s_{2}$ - зависимость между двумя инструкциями в цикле, то некоторый экземпляр $s_{1}$ должен быть выполнен до некоторого экземпляра $s_{2}$, и наоборот. Заметим, что такая взаимозависимость наблюдается, только если $s_{1}$ и $s_{2}$ находятся в одном общем цикле. Из-за этой взаимозависимости мы не можем выполнить все экземпляры одной инструкции до другой, а значит, и выполнить расщепление. С другой стороны, если зависимость $s_{1} \to s_{2}$ - однонаправленная, то можно разделить цикл и сначала выполнить все инструкции $s_{1}$, а затем все инструкции $s_{2}$.

\textbf{Еще немного, но полезнее:}
\textbf{Построение:}

\textbf{Граф зависимости по управлению:}
\begin{itemize}
\item Строим множество ребер ГПУ S
\item Выбираем очередное ребро (A, B) из S. Проходим по дереву постдоминаторов от B до родителя A, помечая каждый пройденный узел за исключением родителя.
\item A как зависящий от A по управлению.
\end{itemize}
Когда в S не останется ребер все зависимости по управлению будут
построены.

\textbf{Граф зависимости по данным:}
\begin{itemize}
    \item Строим множество ребер ГПУ S
    \item Для каждого базового блока можно построить ОАГ (DAG). Обычно каждому использованию переменной в блоке соответствует листовой узел ОАГ; такие узлы называются узлами слияния (склейки).
    \item Потом выполняется анализ потока данных для вычисления достигающих определений на входе в каждый базовый блок с дополнительным требованием, чтобы на входе в программу каждой переменной присваивалось значение “undef”.
    \item Наконец отдельные ОАГ соединяются один с другим, используя результаты анализа потока данных: добавляются ребра, соединяющие узлы-определения с соответствующими узлами
слияния. (Это делает DU-цепочки явными).
\end{itemize}


\textbf{Применение:}

\begin{itemize}
\item 1) Граф зависимостей программы облегчает определение того, можно ли разделить инструкции в цикле. Инструкции, соединенные в цикл в PDG, разделены быть не могут.
\item 2) Вынесение инвариантного кода из цикла
\item 3) Статические и динамические слайсы. \textbf{Слайс программы для инструкции n и переменной x} – множество инструкций программы, которые могут повлиять на значение x перед инструкцией n.
Инструкция может повлиять на значение переменных точке n потому что:
Определяет будет ли вообще выполняться \textbf{(зависимость по управлению)}
Инструкция определяет значение переменной, которая используется в n \textbf{(зависимость по данным)}
\item 4) В компиляторах и формальных языках:
Планирование инструкций. Граф зависимостей вычисляется для операндов ассемблера или промежуточных инструкций и используется для определения оптимального порядка инструкций. + Удаление мёртвого кода.
\end{itemize}

\textbf{Зависимость по данным}:

Определение переменной v в выражении s1 достигает
использования переменной v в выражении s2.
\begin{itemize}
\item \textbf{прямая (или истинная) зависимость:}
переменная, определяемая в $S1$ , используется в $S2$
$a = b + c; S1$
$d = a * t + 1; S2$
\item \textbf{обратная зависимость (или антизависимость):}
переменная, используемая в $S1$ , переопределяется в $S2$.
$a = d + c; S1$
$d = a * t + 1; S2$
\item \textbf{зависимость по записи:}
переменная, определяемая в S1 , переопределяется в S2.
$d = a + c; S1$
$d = a * t + 1; S2$



\end{itemize}

\textbf{Зависимость по управлению}:
Условное выражение s1 определяет, будет или нет выполнено выражение s2




