\nsection{OSN 15 Абстрактные модели: ошибки первого и второго родов (false positives, false negatives). Предикатная абстракция программ и уточнение абстракции по контрпримерам (CEGAR). Ее использование для верификации программ на языках программирования.}

2) смотри сюда: \url{http://sp.cmc.msu.ru/courses/vmp/kamkin_mc2018.pdf}, 
Страничка 173

\paragraph{}
Семантика LTL определяется на траекториях \textbf{структур Крипке}, т.е. на бесконечных последовательностях пометок -- \textit{множеств истинных элементарных высказываний}.

\paragraph{}
В вычислениях программ таких пометок нет, однако никто не мешает ввести высказывания о состояниях программы и использовать их для выражения требований. 
Например, если в программе есть переменные x и y,
можно определить высказывание (предикат) $p \equiv (x > y)$ и, <<измерив>> его истинность на всех состояниях некоторого вычисления проверить свойство $\textbf{G} \neg p$ (никогда значение переменной y не превосходит значения переменной x).

\paragraph{}
Для формальной верификации интерес представляют не одиночные траектории, а \textbf{все возможные траектории}. 
Для их представления нужно по программе построить ее модель в форме структуры Крипке.

\textbf{Структурой Крипке} называется четверка $\langle S, S_0, R, L \rangle$, где S -- множество \textit{состояний}, $S_0 \subseteq S$ -- множество \textit{начальных состояний}, $R \subseteq S \times S$ -- отношение переходов, $L:S \rightarrow 2^{AP}$ -- \textit{функция разметки}, помечающая каждое состояние структуры множеством истинных в нем элементарных высказываний (AP) (с помощью функции разметки задается интерпретация состояний).

Подробнее про структуры Крипке: страничка 144

\paragraph{}

\textit{Состояние}, или \textit{конфигурация}, является естественной концепцией, используемой в программировании. 
Это <<мгновенный снимок>> исполнения программы, включающий состояние данных (значения переменных) и состояние управления (точки исполнения процессов).

Пренебрегая некоторыми деталями, состояния можно объединять в классы эквивалентности, называемые абстрактными состояниями. 
Формализуем эту идею применительно к структурам Крипке:

Пусть заданы множество элементарных высказываний AP и структура Крипке $\langle S, S_0, R, L \rangle$, которую мы будем называть конкретной \textit{системой переходов}. 
Пусть $\hat{S}$  -- некоторое непустое множество -- множество абстрактных состояний. 
\textbf{Функцией абстракции} называется отображение $f: S \rightarrow \hat{S}$, такое что для всех $s, s' \in S$ имеет место импликация:

\begin{equation}
	(f(s) = f(s')) \rightarrow (L(s) = L(s')).
\end{equation}

\textit{Абстрактной системой переходов}, порожденной функцией абстракции f, называется система $\langle  \hat{S},  \hat{S_0},  \hat{R},  \hat{L} \rangle$, где

\begin{displaymath}
  \hat{S_0} = \{f(s) | s \in S_0\}, \hat{R} = \{ (f(s), f(s')) | (s, s') \in R \}
\end{displaymath}
  и
\begin{displaymath}
  \hat{L} (f(s)) = L(s) 
\end{displaymath}
для всех $s \in S$

\indent
\newline
Появление дополнительных траекторий в абстрактных моделях может привести к \textit{ложным сообщениям об ошибках} (\textit{false positives}), или, как их называют в математической статистике, \textbf{ошибкам первого рода}.

Для каждого найденного примера ошибочного поведения, так называемого \textit{контрпримера}, нужно проверить, \textit{реализуем ли он в исходной модели}: если нет, это не ошибка. 
Безусловно, ложные тревоги доставляют неприятности при анализе моделей, но гораздо более опасны \textbf{пропуски ошибок} (\textit{false negatives}) -- \textbf{ошибки второго рода}.

Если ошибки первого рода допустимы, то ошибки второго рода неприемлемы ни при каких обстоятельствах. 
Будем называть модель \textit{адекватной}, если она не допускает ошибок второго рода, а ее анализ требует привлечения приемлемых ресурсов (включая затраты на разбор ошибок первого рода).

\paragraph{Примечание снизу учебника:}
Ошибки \textbf{первого} и \textbf{второго} родов -- ключевые понятия проверки статистических гипотез. 
Ошибка \textbf{первого рода} -- нулевая гипотеза (например, гипотеза <<в программе нет ошибок>>) \textbf{неверно отвергнута}; ошибка \textbf{второго рода} -- нулевая гипотеза \textbf{неверно принята}.

\paragraph{Предикатные абстракции}

Пусть p -- предикат, заданный на множестве состояний S. Обозначим множество состояний, в которых предикат p истинен, как $[[p]]$, т.е. $[[p]] = \{s \in S | s \models p\}$.
Введем специальные предикаты \textit{false} и \textit{true}:
\begin{displaymath}
	[[false]] = \emptyset 
\end{displaymath}
и 
\begin{displaymath}
	[[true]] = S
\end{displaymath}

Пусть задано конечное множество предикатов $\{p_1, ..., p_n\}$.
Регионом называется предикат вида $\wedge^{m}_{k=1} p_{i_k}$, где $1 \leq i_1 < ... < i_m \leq n$, либо \textit{false}.
Если $m = 0$ то регион совпадает с \textit{true} (очевидно из формулы лол).

\paragraph{}
Метод абстракции, состоящий в «замене» конкретных состояний программы на формулы, описывающие множества состояний, называется \textbf{предикатной абстракцией}. 

Если формулы имеют вид \textit{регионов} (для некоторого заданного множества предикатов), метод называется \textbf{\textit{декартовой} предикатной абстракцией}.

\paragraph{CEGAR}

Метод CEGAR (\textit{Counter Example Guided Abstraction Refinement}) применяется для проверки достижимости определенной точки программы. Основная идея состоит в следующем:


Проверяется модель программы: если анализ выявляет, что модель корректна (заданная точка недостижима), то корректна и исходная программа (ошибки второго рода исключены); 
в противном случае для модели строится контрпример -- путь в заданную точку: если этот путь реализуем и в исходной программе, программа некорректна; 
иначе негативный результат проверки есть всего лишь ложная тревога, являющаяся следствием абстрагирования от чего-то существенного.
От чего именно, выявляется путем анализа контрпримера; модель уточняется, и к ней применяется тот же алгоритм. 
В результате ряда итераций метод CEGAR либо найдет путь в заданную точку, либо докажет ее недостижимость, либо, есть и такая возможность, упрется в ограничения по ресурсам.

\paragraph{Общая схема работы (формализованно):}

\begin{enumerate}
	\item Текущее множество предикатов полагается пустым.
	\item Строится абстрактная модель программы для текущего множества предикатов.
	\item Проверяется корректность абстрактной модели (недостижимость точки \textit{error}):
		\begin{enumerate}
			\item Если модель корректна, корректна и исходная программа.
			\item Иначе исполняется шаг 4.
		\end{enumerate}
	\item Строится контрпример $\pi$ -- вычисление из начальной конфигурации в конфигурацию вида $\langle \textit{error}, r \rangle$, где r -- регион, отличный от $\textit{false}$. \newline Конструируется сильнейшее постусловие $sp(op(\pi), \textit{true})$, где $\textit{op}(\pi)$ -- цепочка операторов SSA-представления, соответствующая вычислению $\pi$.
	\item Проверяется выполнимость формулы $sp(op(\pi), \textit{true})$:
		\begin{enumerate}
			\item Если формула выполнима, исходная программа некорректна и $\pi$ -- контрпример.
			\item Иначе исполняется шаг 6.
		\end{enumerate}
	\item Уточняется текущее множество предикатов: во множество добавляются предикаты, построенные на основе цепочки операторов $\textit{op}(\pi)$. \newline Осуществляется переход к шагу 2.
\end{enumerate}

Я честно очень устал это вбивать, потому про то, как осуществляется уточнение предикатов лучше прочитайте сами на страницах 188-189. Не думаю что это здесь нужно.










