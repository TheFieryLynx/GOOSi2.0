\nsection{OSN 14 . Проблемы статического анализа объектно-ориентированных языков (C++, Java). Поток управления в присутствии исключений. Вызовы по указателю и их анализ. Понятие одевиртуализации.}

Проблемы:
\begin{itemize}
    \item Использование динамического полиморфизма означает, что определенный метод может вызываться для разных объектов, и это может быть известно только во время выполнения. Это затрудняет точный анализ кода на этапе компиляции.
    
    \item Также в С++ есть проблемы, связанные с использованием указателей и ссылок, которые могут привести к неопределенному поведению во время выполнения. Такие проблемы могут быть трудными для обнаружения статическим анализом.
    \item В Java, статический анализ также имеет свои ограничения относительно анализа потока управления. В частности, использование динамической загрузки классов может привести к тому, что методы и поля будут известны только во время выполнения
\end{itemize}

В присутствии исключений поток управления может значительно изменится. Требуется рассматривать несколько вариантов развития событий одновременно и анализировать несколько путей.

Проблемы с вызовом по указателю в том, что достоверно может быть не известен адрес, по которому мы будем переходить. Мы можем только попытаться как-то сузить в общем случае область переходов с помощью анализа указателей. Естественно восстановить гарантировано поток управления в этом случае мы не можем.

\textbf{Одевиртуализация}. Виртуальный вызов называется \textit{мономорфным}, если при исполнении связывается с одним и тем же методом. Во время исполнения типичного приложения более 90\% произведенных виртуальных вызовов являются мономорфными бесконтекстно и 98\% в динамическом контексте вызовов глубиной не более 1. Во время компиляции необходимо обнаружить большинство таких виртуальных вызовов и заменить их на прямые (статические) вызовы.

\textbf{Алгоритм одевиртуализации}. Вычислить набор классов для аргументов диспетчеризации виртуального вызова:
\begin{itemize}
    \item Конструкторы и литералы выдают конкретный класс
    \item Если язык типизированный, то для всех прочих случаев проще всего отфильтровать классы по типу
    \item Если тип — это класс, то набор всех его подклассов
    \item  Если тип — это интерфейс, то набор всех подклассов классов,
реализующих этот интерфейс и его подинтерфейсы
\end{itemize}

Если в полученном наборе классов имеется единственный метод с подходящей для виртуального вызова сигнатурой, заменить этот виртуальный вызов статическим вызовом этого метода.
