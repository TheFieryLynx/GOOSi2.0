\nsection{OSN 9 Применение отладки для оценки возможности эксплуатации уязвимостей. Технологии отладки. Отладка пользовательского кода. Полносистемная отладка ввиртуальной машине. Статическое и динамическое инструментирование. Фаззинг. Разновидности фаззинга: черный ящик, белый ящик, серый ящик.}

\textbf{Для эксплоитов}
\begin{itemize}
  \item Сопоставление объектов низкого уровня (адресов, неструктурированных данных) с объектами высокого уровня (функциями, строками кода, типизированными данными).
  \item Компилятор может выдавать отладочную информацию, описывающую соответствие между сгенерированным бинарным кодом и исходным кодом, из которого он был получен
\end{itemize}

\textbf{Отладка пользовательского кода}
\begin{itemize}
    \item “Print-debugging” — добавление в программу вывода значений переменных в окрестности ошибки.
    \item Бисекция (<<wolf fence>> algorithm) — способ локализации ошибки:
    \begin{itemize}
        \item временное отключение частей кода с поиском того момента, когда ошибка перестаёт воспроизводиться;
        \item наоборот, последовательное включение частей кода с поиском того момента, когда ошибка начнёт воспроизводиться.
    \end{itemize}
    \item  Применение отладчика:
    \begin{itemize}
        \item локальная отладка (на той же самой машине);
        \item удалённая отладка (через сетевое соединение).
        \item Отладчик подключается к выполняющемуся процессу либо к дампу памяти (core dump), полученному при аварийном завершении программы.
    \end{itemize}
\end{itemize}



\textbf{Базовый функционал отладчика}
\begin{itemize}
    \item Точка останова (breakpoint) — адрес команды, при достижении которого выполнение программы должно быть приостановлено.
    \item Точка отслеживания (watchpoint) — адрес ячейки памяти, при обращении к которой на чтение или запись выполнение программы должно быть приостановлено.
    \item  Пошаговое выполнение программы — выполнение одной машинной команды или одной строки исходного кода (с использованием отладочной информации).  В момент, когда выполнение программы приостановлено, отладчик предоставляет возможность просмотра содержимого регистров и памяти.
\end{itemize}
\textbf{Поддержка}
\begin{itemize}
    \item Точки останова реализуются через внедрение команды \textit{INT 3} (аппаратная поддержка) в тело программы по требуемому адресу.
    \item Команда INT 3 кодируется единственным байтом \textit{0xCC}.
    \item Отладчик сохраняет содержимое первого байта по адресу точки останова и заменяет его в загруженном в память образе программы на команду \textit{INT 3}.
    \item При достижении потоком управления команды \textit{INT 3} процессор генерирует отладочное прерывание, которое при поддержке со стороны операционной системы перехватывается отладчиком.
    \item Операционная система приостанавливает выполнение потока, в котором возникло прерывание, до дальнейших указаний от отладчика.
\end{itemize}

\textbf{Пошаговое выполнение}: Установка бита \textit{TF} в регистре \textit{RFLAGS} приводит к тому, что после выполнения каждой очередной команды генерируется отладочное исключение.

\textbf{Отладка в виртуальной машине}
Отладка может выполняться в полносистемном эмуляторе (виртуальной машине), например, в QEMU. В этом случае отладчик (GDB) подключается не к выполняющемуся на той же машине процессу, а через сетевое соединение к ответной части (GDB debugging stub) в эмуляторе.

Основное преимущество отладки в виртуальной машине — исключение влияния наличия отладчика на поведение отлаживаемой системы.(кроме увеличения времени выполнения).

Основные недостатки — относительная сложность подготовки окружения и семантический разрыв.

\textbf{Семантический разрыв}
\begin{enumerate}
    \item Полносистемная отладка предоставляет полную информацию о состоянии машины.
    \item Имеется возможность отладки драйверов и ядра ОС: можно обращаться к структурам данных, которые недоступны обычным отладчикам.
    \item  Вместе с тем, отладка осуществляется на низком уровне (значения регистров, неинтерпретируемое содержимое памяти и т.д.).
    \item Существует семантический разрыв — состояние системы как его «понимает» отладчик и как его понимает оператор, находятся на разных уровнях.
\end{enumerate}

\textbf{Инструментирование} — добавление в существующую программу блоков кода,
осуществляющих отслеживание каких-либо её характеристик во время выполнения.

\textbf{Статическое инструментирование} выполняется однократно перед запуском
программы. Статическое инструментирование может выполняться:
\begin{itemize}
    \item на уровне исходного кода — вручную или автоматически;
    \item на уровне бинарного кода — вручную или автоматически.
\end{itemize}

\textbf{<<Print-debugging>>} — пример выполненного вручную статического инструментирования на уровне исходного кода с целью отладки программы.

Динамическое инструментирование бинарного кода (DBI) — разновидность инструментирования бинарного кода, выполняемого во время работы программы.

Динамическое инструментирование бинарного кода родственно JIT компиляции, т.к. предполагает построение выполняющегося кода <<на лету>>.

Подходы к выполнению инструментирования блока трансляции:
\begin{itemize}
    \item копирование и аннотирование (C\&A — copy-and-annotate);
    \item <<дизассемблирование>> и ресинтезирование (D\&R: disassembleand-resynthesize).
\end{itemize}

\textbf{Фаззинг} – подход к тестированию программных систем, при котором на вход системе передаётся большое количество образцов входных данных, сгенерированных другой программой (фаззером). Процесс их обработки контролируется с целью обнаружения ошибок.

Отличие от других видов тестирования:
\begin{itemize}
    \item <<Классическое тестирование>> - запуск программы на множестве нормальных входов с целью предотвращения обнаружения ошибок обычными пользователями.
    \item Фаззинг - запуск программы на множестве аномальных входов, детектирование проблем с целью предотвращение обнаружения эксплуатируемых уязвимостей атакующими.
\end{itemize}

Схема использования фаззинга
\begin{enumerate}
    \item Определить источник входных данных программы
    \item  Случайное мутирование корректного входа или гененерация псевдослучайных данных
    \item Использование оракула для мониторинга аварийных завершений
    \item Запись входных данных и состояния на которых произошло аварийное
завершение
\end{enumerate}

Причины возникновения и использования:
\begin{itemize}
    \item Высокая скорость работы, легко параллелится
    \item Не требует наличия исходного кода программы
    \item Не требует написания тестов
    \begin{itemize}
        \item Ручное тестирование и разработка тестов дороги 
    \end{itemize}
    \item У разработчиков тестов обычно есть <<слепые пятна>>
    \item Относительно просто реализуется
    \item Переносимость/Повторное использование
    \item Высокая доля истинных ошибок по сравнению со статическими анализаторами
\end{itemize}

Классификация методов фаззинга:
\begin{itemize}
    \item Фаззинг по методу <<чёрного ящика>> - генерация входных данных без обратной связи с анализируемой программой – только детектирование ошибок.
    \item Фаззинг по методу <<серого ящика>> - генерация входных данных на основании наблюдения за выполнением программы.
    \item  Фаззинг по методу «белого ящика» - генерация входных данных на основе предварительного запуска программы на корректных данных, построения уравнений пути и их решения в ходе символьного выполнения программы наблюдения за выполнением программы.
\end{itemize}
